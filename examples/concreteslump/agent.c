/* Cartesian Genetic Program
   Evolved using libgpr
   https://launchpad.net/libgpr

   To compile:
gcc -Wall -std=c99 -pedantic -o agent agent.c -lm
*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

const int sensors = 7;
const int actuators = 3;
const int rows = 9;
const int columns = 16;
const int connections_per_gene = 11;
float * genome[1];
float * state[1];
int tick = 0;

/* Genome for ADF_module 0 */
float gene0[] = {23,-16.016,4,5,1,0,3,1,6,4,5,0,6,-1,-1,0,0,-1,-1,-1,-1,0,0,-1,6,-13.852,3,4,0,0,2,1,0,6,1,1,6,-1,0,-1,0,-1,-1,-1,-1,0,0,-1,4,9.720,6,3,1,0,2,5,6,2,2,1,0,0,0,-1,0,0,0,-1,0,0,-1,-1,34,-101.129,1,5,1,5,5,4,5,1,1,1,2,0,-1,-1,-1,0,0,-1,-1,-1,0,-1,18,12.124,4,1,5,5,5,2,1,2,6,1,5,0,0,0,-1,0,-1,-1,0,0,0,0,27,60.080,3,2,5,1,1,1,0,3,6,5,6,0,-1,-1,0,-1,-1,-1,0,-1,-1,0,22,98.584,3,5,2,5,2,0,4,4,0,2,1,-1,-1,-1,0,-1,0,0,0,0,-1,0,23,-92.960,3,2,1,6,1,4,1,0,3,2,4,-1,0,0,-1,-1,-1,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-48.120,5,4,1,5,4,9,3,5,13,7,13,-1,0,0,-1,0,-1,-1,-1,-1,0,0,8,58.432,13,4,7,4,4,6,15,13,8,8,5,-1,0,-1,-1,-1,-1,0,0,0,-1,-1,2,-63.836,10,4,9,11,8,5,4,9,15,10,11,0,0,0,-1,0,0,-1,0,-1,-1,-1,1,-47.040,8,5,8,15,13,9,3,14,1,4,0,0,-1,0,-1,-1,0,0,-1,-1,-1,0,41,-73.180,4,1,12,15,9,0,12,1,1,0,10,0,-1,0,0,-1,0,-1,-1,0,-1,0,21,-97.048,5,0,2,14,8,13,2,6,11,14,11,0,0,0,0,0,-1,0,-1,-1,0,0,23,6.680,0,11,0,1,2,3,1,12,7,7,7,0,-1,-1,-1,-1,0,-1,-1,0,0,0,15,-25.901,5,0,11,2,11,15,3,6,10,3,15,-1,0,0,-1,0,-1,-1,-1,0,-1,0,27,74.260,11,11,3,1,5,13,14,8,4,15,12,0,-1,-1,-1,0,0,-1,-1,-1,-1,0,6,37.699,6,1,1,15,4,8,16,6,15,17,12,-1,0,0,0,0,0,-1,0,0,-1,-1,22,-51.148,18,17,19,18,24,9,5,17,10,23,20,0,0,-1,0,-1,-1,-1,0,-1,-1,0,42,37.200,21,0,4,11,0,23,14,17,11,14,18,0,0,-1,0,0,0,-1,-1,0,-1,0,16,-96.905,19,10,14,3,15,18,7,9,18,19,8,0,-1,-1,-1,0,0,-1,-1,-1,-1,-1,25,-99.902,16,21,19,10,3,14,11,19,9,20,11,-1,-1,0,-1,0,-1,-1,0,0,0,0,9,-101.295,8,4,17,5,8,12,20,3,7,4,21,0,0,-1,0,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,13,32.033,19,3,23,0,17,16,7,22,3,19,13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,37,66.320,9,5,20,25,24,19,26,23,28,16,2,0,-1,-1,-1,0,0,-1,-1,-1,0,-1,43,10.165,16,21,5,17,16,26,19,3,12,22,33,-2147483648,-1,0,0,-1,-1,0,-1,0,0,-1,10,10.323,21,30,17,18,10,4,9,22,32,20,4,0,0,-1,0,0,-1,-1,-1,0,0,0,11,11.240,25,0,0,30,14,30,24,7,33,0,9,-2147483648,-2147483648,0,0,-1,1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-69.980,18,14,8,0,20,5,29,27,6,4,11,-1,-1,0,-1,0,-1,-1,0,-1,0,-1,23,-18.560,7,5,3,6,8,5,0,3,16,23,15,0,-1,-1,0,0,-1,-1,0,0,0,0,4,-18.606,6,7,3,1,5,14,26,5,0,13,4,0,-1,0,-1,0,0,-1,-1,0,0,0,19,23.674,11,8,2,30,2,1,14,6,17,6,4,0,-1,0,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,33,-54.457,42,35,33,37,21,7,38,6,7,5,2,0,-1,-1,-1,0,-1,-1,0,-1,-1,0,9,3.300,22,4,6,5,4,42,35,40,0,10,11,0,0,-1,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,83.733,41,3,8,0,3,3,2,0,0,4,0,-1,0,-1,0,0,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,28.700,6,1,9,21,0,11,6,8,6,8,25,-1,-1,0,0,-1,-1,-1,0,-1,-1,-1,31,-49.120,7,14,6,1,8,26,3,7,1,3,3,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-73.464,7,45,4,6,1,9,4,30,2,9,0,0,0,-1,0,0,0,-1,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-70.494,7,19,46,37,0,6,14,14,6,52,6,-1,-1,0,0,-1,0,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,79.060,3,3,6,6,53,17,13,55,5,16,40,-1,0,0,0,0,-1,0,-1,0,0,-1,11,32.420,1,50,0,57,26,33,10,7,17,29,48,0,-1,-1,-1,-1,0,0,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,-18.740,1,29,39,16,34,33,15,3,17,8,13,-1,-1,0,-1,-1,-1,-1,-1,0,-1,-1,15,19.521,34,53,43,16,11,24,14,9,16,10,47,0,-1,0,-1,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-98.157,40,53,44,13,42,12,64,67,65,35,19,-1,-1,0,-1,0,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,34,-79.093,3,25,16,50,33,0,35,67,14,28,0,0,0,-1,-1,0,-1,0,0,0,0,-1,1,-35.987,46,8,32,17,15,62,11,16,63,18,23,-1,0,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,45.220,62,7,15,68,24,12,7,77,25,4,49,0,-1,0,-1,-1,-1,0,-1,0,0,0,9,-80.560,37,70,26,22,22,60,19,59,16,2,29,-1,0,0,0,-1,0,-1,-1,-1,-1,-1,16,51.954,5,20,24,16,4,18,5,75,2,60,12,0,-1,-1,-1,0,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,24,-100.539,16,31,37,35,57,91,20,26,87,56,69,0,0,0,0,-1,-1,0,-1,0,0,-1,6,75.732,81,27,53,4,14,85,3,1,18,31,56,-1,-1,0,0,0,-1,0,0,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-22.760,18,45,31,48,33,15,20,15,94,22,103,0,0,-1,-1,0,0,-1,0,0,0,-1,22,51.980,79,102,14,50,93,90,10,31,21,0,44,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,37,-32.663,36,25,6,47,80,49,103,24,30,41,81,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,34,-14.960,107,39,113,76,106,75,8,93,23,56,63,-1,0,0,0,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-30.941,117,73,97,5,58,3,20,25,33,42,6,-1,-1,-1,0,0,0,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,68,77,149};

/* State array for ADF_module 0 */
float state0[154];

void get_inputs(int argc, char* argv[])
{
  int i;

  for (i = 0; i < argc; i++) {
    state[0][i] = atof(argv[i]);
  }
}

void run(int ADF_module)
{
  int row,col,n=0,i=0,j,k,g,ctr,src,dest,
block_from,block_to,no_of_args;
  int sens,act;
  float * gp;

  if (ADF_module == 0) {
    sens = sensors;
    act = actuators;
  }
  else {
    sens = 10;
    act = 1;
  }

  for (col = 0; col < columns; col++) {
    for (row = 0; row < rows; row++, i++,n+=24) {
      if (genome[ADF_module][n] < 0) continue;
      gp = &genome[ADF_module][n];
      switch((int)gp[0]) {
      case 46: {
        break;
      }
      case 23: {
        j = abs((int)state[ADF_module][(int)gp[2]] + (int)state[ADF_module][(int)gp[3]])
            %(rows*columns);
        state[ADF_module][sens+i] = state[ADF_module][sens+j];
        break;
      }
      case 22: {
        j = abs((int)state[ADF_module][(int)gp[3]])
            %(rows*columns);
        state[ADF_module][sens+i] = gp[1]*state[ADF_module][(int)gp[2]];
        state[ADF_module][sens+j] = state[ADF_module][sens+i];

        if (state[ADF_module][sens+j] > 4096) {
          state[ADF_module][sens+j] = 4096;
        }
        if (state[ADF_module][sens+j] < -4096) {
          state[ADF_module][sens+j] = -4096;
        }
        break;
      }
      case 1: {
        state[ADF_module][sens+i] = (int)gp[1];
        break;
      }
      case 32: {
        no_of_args =
          1 + (abs((int)gp[1])%(10));
        state[ADF_module][sens+i] = 0;
        for (j = 0; j < no_of_args; j++) {
          state[ADF_module][sens+i] +=
            state[ADF_module][(int)gp[2+j]]*            gp[j+13];
        }

        state[ADF_module][sens+i] =
          1.0f / (1.0f + exp(-state[ADF_module][sens+i]));
        break;
      }
      case 2: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = 0;
        for (j = 0; j < no_of_args; j++) {
          state[ADF_module][sens+i] += state[ADF_module][(int)gp[2+j]];
        }
        break;
      }
      case 3: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        for (j = 0; j < no_of_args; j++) {
          state[ADF_module][sens+i] -= state[ADF_module][(int)gp[2+j]];
        }
        break;
      }
      case 4: {
        state[ADF_module][sens+i] = -(int)state[ADF_module][(int)gp[2]];
        break;
      }
      case 5: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        for (j = 0; j < no_of_args; j++) {
          state[ADF_module][sens+i] *= state[ADF_module][(int)gp[2+j]];
        }
        break;
      }
      case 6: {
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]] * gp[1];
        break;
      }
      case 7: {
        if (state[ADF_module][(int)gp[3]] == 0) {
          state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        }
        else {
          state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]] / state[ADF_module][(int)gp[3]];
        }
        break;
      }
      case 8: {
        if ((int)state[ADF_module][(int)gp[3]] == 0) {
          state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        }
        else {
          state[ADF_module][sens+i] = (int)state[ADF_module][(int)gp[2]] % (int)state[ADF_module][(int)gp[3]];
        }
        break;
      }
      case 9: {
        state[ADF_module][sens+i] = floor(state[ADF_module][(int)gp[2]]);
        break;
      }
      case 10: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        for (j = 1; j < no_of_args; j++) {
          state[ADF_module][sens+i] += state[ADF_module][(int)gp[2+j]];
        }
        state[ADF_module][sens+i] /= no_of_args;
        break;
      }
      case 11: {
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        break;
      }
      case 12: {
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        break;
      }
      case 13: {
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        break;
      }
      case 14: {
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        break;
      }
      case 15: {
        if (state[ADF_module][(int)gp[2]] > state[ADF_module][(int)gp[3]]) {
          state[ADF_module][sens+i] = (int)gp[1];
        }        else {          state[ADF_module][sens+i] = 0;
        }        break;
      }
      case 16: {
        if (state[ADF_module][(int)gp[2]] < state[ADF_module][(int)gp[3]]) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 17: {
        if (state[ADF_module][(int)gp[2]] == state[ADF_module][(int)gp[3]]) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 18: {
        if ((state[ADF_module][(int)gp[2]]>0) &&
            (state[ADF_module][(int)gp[3]]>0)) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 19: {
        if ((state[ADF_module][(int)gp[2]]>0) ||
            (state[ADF_module][(int)gp[3]]>0)) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 20: {
        if ((state[ADF_module][(int)gp[2]]>0) !=
            (state[ADF_module][(int)gp[3]]>0)) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 21: {
        if (((int)state[ADF_module][(int)gp[2]]) !=
            ((int)state[ADF_module][(int)gp[3]])) {
          state[ADF_module][sens+i] = (int)gp[1];
        }
        else {
          state[ADF_module][sens+i] = 0;
        }
        break;
      }
      case 43: {
        no_of_args =
          1 + (abs((int)gp[1])%(10));
        state[ADF_module][sens+i] = 0;
        for (j = 0; j < no_of_args; j++) {
          state[ADF_module][sens+i] +=
            state[ADF_module][(int)gp[2+j]] *
            gp[j+13];
        }
        for (j = 0; j < no_of_args; j++) {
          gp[j+13] +=
            state[ADF_module][sens+i] * state[ADF_module][(int)gp[2+j]] * 0.001000;
        }
        break;
      }
      case 24: {
        state[ADF_module][sens+i] = (float)exp(state[ADF_module][(int)gp[2]]);
        break;
      }
      case 25: {
        state[ADF_module][sens+i] = (float)sqrt(fabs(state[ADF_module][(int)gp[2]]));
        break;
      }
      case 26: {
        state[ADF_module][sens+i] = (float)fabs(state[ADF_module][(int)gp[2]]);
        break;
      }
      case 27: {
        state[ADF_module][sens+i] = (float)(sin(state[ADF_module][(int)gp[2]])*256);
        break;
      }
      case 28: {
        state[ADF_module][sens+i] = (float)asin(state[ADF_module][(int)gp[2]]);
        break;
      }
      case 29: {
        state[ADF_module][sens+i] = (float)(cos(state[ADF_module][(int)gp[2]])*256);
        break;
      }
      case 30: {
        state[ADF_module][sens+i] = (float)acos(state[ADF_module][(int)gp[2]]);
        break;
      }
      case 31: {
        state[ADF_module][sens+i] = (float)pow(state[ADF_module][(int)gp[2]],state[ADF_module][(int)gp[3]]);
        break;
      }
      case 33: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        for (j = 1; j < no_of_args; j++) {
          if (state[ADF_module][(int)gp[2+j]] < state[ADF_module][sens+i]) {
            state[ADF_module][sens+i] = state[ADF_module][(int)gp[2+j]];
          }
        }
        break;
      }
      case 34: {
        no_of_args = 1 + (abs((int)gp[1])%10);
        state[ADF_module][sens+i] = state[ADF_module][(int)gp[2]];
        for (j = 1; j < no_of_args; j++) {
          if (state[ADF_module][(int)gp[2+j]] > state[ADF_module][sens+i]) {
            state[ADF_module][sens+i] = state[ADF_module][(int)gp[2+j]];
          }
        }
        break;
      }
      case 35: {
        if (((int)gp[2] > sens) && ((int)gp[3] > sens)) {
          src = ((int)gp[2]-sens)*24;
          dest = ((int)gp[3]-sens)*24;
          genome[ADF_module][dest] = genome[ADF_module][src];
        }
        break;
      }
      case 36: {
        if (((int)gp[2] > sens) && ((int)gp[3] > sens)) {
          src = ((int)gp[2]-sens)*24;
          dest = ((int)gp[3]-sens)*24;
          genome[ADF_module][dest+1] = genome[ADF_module][src+1];
        }
        break;
      }
      case 37: {
        state[ADF_module][(int)gp[3]] = state[ADF_module][(int)gp[2]];
        break;
      }
      case 38: {
        block_from = (int)gp[2];
        block_to = (int)gp[3];
        if (block_from<block_to) {
          block_from = (int)gp[3];
          block_to = (int)gp[2];
        }
        k = block_to - 2;
        for (j = block_from - 2;
             j <= block_from + 2; j++,k++) {
          if ((j>sens) &&
              (k>sens) &&
              (j<i) && (k<i)) {
            for (g = 0; g < 24; g++) {
              genome[ADF_module][(j-sens)*24 + g] =
                genome[ADF_module][(k-sens)*24 + g];
            }
          }
        }
        break;
      }
      case 39: {
        if (gp[2] > sens) {
          src = ((int)gp[2] - sens) * 24;
          gp[3] = genome[ADF_module][src+2];
        };
        break;
      }
      case 40: {
        if (gp[3] > sens) {
          src = ((int)gp[2] - sens) * 24;
          gp[2] = genome[ADF_module][src+2];
        };
        break;
      }
      case 41: {
        if (gp[3] > sens) {
          src = ((int)gp[2] - sens) * 24;
          gp[2] = genome[ADF_module][src+3];
        };
        break;
      }
      case 42: {
        if (gp[2] > sens) {
          src = ((int)gp[2] - sens) * 24;
          gp[3] = genome[ADF_module][src+3];
        };
        break;
      }
      }
      /* prevent values from going out of range */
      if ((isnan(state[ADF_module][sens+i])) || (isinf(state[ADF_module][sens+i]))) {
        state[ADF_module][sens+i] = 0;
      }
      if (state[ADF_module][sens+i] > 4096) {
        state[ADF_module][sens+i] = 4096;
      }
      if (state[ADF_module][sens+i] < -4096) {
        state[ADF_module][sens+i] = -4096;
      }
    }
  }

  /* set the actuator values */
  ctr = sens + i;
  for (i = 0; i < act; i++, ctr++, n++) {
    state[ADF_module][ctr] = state[ADF_module][(int)genome[ADF_module][n]];
  }
}

void set_outputs()
{
  int i;

  for (i = 0; i < actuators; i++) {
    if (i > 0) printf(" ");
    printf("%.3f",state[0][sensors+(rows*columns)+i]);
  }
  printf("\n");
}

static void setup()
{
  int i,j;


  /* Clear the state array */
  for (i = 0; i < sensors + (rows*columns) + actuators; i++) {
    for (j = 0; j < 0; j++) {
      state[j][i] = 0;
    }
  }

}

static int read_stdin_args(char *argv[])
{
  char argstr[1024], value[1024], *retval;
  int i,ctr=0,field_index=0;
  FILE * fp = fopen("stdin","r");

  if (!fp) return 0;
  while (!feof(fp)) {
    retval = fgets(argstr,1023,fp);
    if (retval) {
      for (i = 0; i < strlen(argstr); i++) {
        if ((argstr[i]==' ') ||
            (argstr[i]==',') ||
            (argstr[i]==';') ||
            (i == strlen(argstr)-1)) {
          if (i == strlen(argstr)-1) {
            value[ctr++] = argstr[i];
          }
          value[ctr] = 0;
          ctr = 0;
          argv[field_index] = (char*)malloc(strlen(value)+2);
          sprintf(argv[field_index++],
"%s",value);
        }
        else {
          value[ctr++] = argstr[i];
        }
      }
    }
  }
  fclose(fp);
  return field_index;
}

int main(int argc, char* argv[])
{
  char * stdin_args[1024];
  int i,no_of_stdin_args =
    read_stdin_args(stdin_args);

  setup();

  if (no_of_stdin_args>0) {
    if (no_of_stdin_args != sensors) {
      printf("Invalid number of arguments %d/%d\n",no_of_stdin_args,sensors);
      for (i = 0; i < no_of_stdin_args; i++) {
        free(stdin_args[i]);
      }
      return -1;
    }
    get_inputs(no_of_stdin_args,stdin_args);
    for (i = 0; i < no_of_stdin_args; i++) {
      free(stdin_args[i]);
    }
  }
  else {
    if (argc-1 != sensors) {
      printf("Invalid number of arguments %d/%d\n",argc-1,sensors);
      return -1;
    }
    get_inputs(argc-1,&argv[1]);
  }

  for (i = 0; i < 2; i++) {
    run(0);
  }
  set_outputs();

  /* Increment the time step */
  tick++;
  if (tick>32000) tick=0;

  return 0;
}

